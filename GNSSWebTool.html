<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow EOS RTK Point Averaging Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        #map {
            height: 400px;
            width: 100%;
            border-bottom: 3px solid #667eea;
        }

        .control-panel {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .section h3 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-export {
            padding: 0.6rem 1.2rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            margin: 0.25rem;
            transition: all 0.3s;
        }

        .btn-export:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        .status-badge {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0.5rem 0;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-collecting {
            background: #fff3cd;
            color: #856404;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .coordinate-display {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coordinate-display strong {
            color: #667eea;
        }

        .coordinate-display span {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .export-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .progress-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .info-card {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }

        .info-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
            margin: 0.5rem 0;
        }

        .info-card .label {
            font-size: 0.9rem;
            color: #666;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.4rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }

            #map {
                height: 300px;
            }

            .export-options {
                flex-direction: column;
            }

            .btn-export {
                width: 100%;
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Arrow EOS RTK Point Averaging Tool</h1>
        <div class="subtitle">1. Connect Arrow via Bluetooth ‚Üí 2. Enter Point Name ‚Üí 3. Start Collection ‚Üí 4. Export Data</div>
    </div>

    <div id="map"></div>

    <div class="control-panel">
        <!-- Device Status -->
        <div class="section">
            <h3>üì° Device Status</h3>
            <div id="deviceStatus">
                <span class="status-badge status-disconnected">Using Browser GPS</span>
            </div>
            <button class="btn btn-primary" onclick="requestBluetoothDevice()" style="margin-top: 1rem;">
                üîµ Connect Arrow Device
            </button>
            <div style="margin-top: 1.5rem; padding: 1rem; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                    <input type="checkbox" id="applyPoleOffset" checked onchange="updateOffsetSettings()" style="width: 20px; height: 20px; cursor: pointer;">
                    <label for="applyPoleOffset" style="cursor: pointer; font-weight: 600; margin: 0;">Apply Arrow 200+ Pole Offset</label>
                </div>
                <div id="offsetDetails" style="font-size: 0.9rem; color: #555; padding-left: 28px;">
                    <strong>Total Offset: 2.035m</strong><br>
                    ‚Ä¢ Range pole height: 2.000 m<br>
                    ‚Ä¢ Mounting plate: 0.025 m<br>
                    ‚Ä¢ Phase center offset: 0.010 m<br>
                    <em>All elevations shown in NAVD88 feet</em>
                </div>
                <div id="noOffsetDetails" style="font-size: 0.9rem; color: #555; padding-left: 28px; display: none;">
                    <strong>No offset applied</strong><br>
                    <em>Elevations shown as raw ellipsoidal height in feet</em>
                </div>
            </div>
        </div>

        <!-- Point Collection -->
        <div class="section">
            <h3>üìç Point Collection</h3>
            
            <div class="form-group">
                <label for="pointName">Point Name</label>
                <input type="text" id="pointName" placeholder="Enter point name">
            </div>

            <div class="form-group">
                <label for="numPoints">Number of Readings (10-200)</label>
                <input type="number" id="numPoints" value="50" min="10" max="200">
            </div>

            <div class="info-grid">
                <div class="info-card">
                    <div class="label">Current Accuracy</div>
                    <div class="value" id="currentAccuracy">--</div>
                </div>
                <div class="info-card">
                    <div class="label">Points Collected</div>
                    <div class="value" id="pointCount">0 / 50</div>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
            </div>

            <button class="btn btn-primary" id="startBtn" onclick="startCollection()">
                ‚ñ∂Ô∏è Start Collection
            </button>
            <button class="btn btn-danger hidden" id="stopBtn" onclick="stopCollection()">
                ‚èπÔ∏è Stop Collection
            </button>
        </div>

        <!-- Results -->
        <div class="section hidden" id="resultsContainer">
            <h3>‚úÖ Averaged Results</h3>
            <div class="coordinate-display">
                <strong>Latitude:</strong>
                <span id="avgLat">--</span>
            </div>
            <div class="coordinate-display">
                <strong>Longitude:</strong>
                <span id="avgLon">--</span>
            </div>
            <div class="coordinate-display">
                <strong>Elevation:</strong>
                <span id="avgElev">--</span>
            </div>
            <div class="coordinate-display">
                <strong>Std Deviation:</strong>
                <span id="stdDev">--</span>
            </div>
            <div class="coordinate-display">
                <strong>Samples:</strong>
                <span id="numSamples">--</span>
            </div>

            <h3 style="margin-top: 1.5rem;">üì§ Export Options</h3>
            <div class="export-options">
                <button class="btn-export" onclick="exportCSV()">üìÑ Export CSV</button>
                <button class="btn-export" onclick="exportGeoJSON()">üó∫Ô∏è Export GeoJSON</button>
                <button class="btn-export" onclick="exportKML()">üåç Export KML</button>
                <button class="btn-export" onclick="exportGPX()">üìç Export GPX</button>
                <button class="btn-export" onclick="copyCoordinates()">üìã Copy Coordinates</button>
            </div>
        </div>

        <!-- Collected Points History -->
        <div class="section hidden" id="historyContainer">
            <h3>üìã Collection History</h3>
            <div id="historyList"></div>
            <button class="btn-export" onclick="exportAllPoints()" style="margin-top: 1rem;">
                üì¶ Export All Points
            </button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map, currentMarker, averagedMarker;
        let isCollecting = false;
        let watchId = null;
        let readings = [];
        let targetPoints = 50;
        let averagedPoint = null;
        let allCollectedPoints = [];
        let bluetoothDevice = null;
        let gpsCharacteristic = null;

        // Conversion from ellipsoidal meters to NAVD88 feet
        // Arrow 200+ offset: 2.000m (pole) + 0.025m (plate) + 0.010m (phase center) = 2.035m
        const ARROW_OFFSET = 2.035; // meters
        
        function convertElevationToFeet(meters) {
            const applyOffset = document.getElementById('applyPoleOffset')?.checked ?? true;
            const offset = applyOffset ? ARROW_OFFSET : 0;
            return (meters + offset) * 3.28084;
        }
        
        // Convert meters to feet (for horizontal measurements)
        function metersToFeet(meters) {
            return meters * 3.28084;
        }
        
        // Update offset display when checkbox changes
        function updateOffsetSettings() {
            const applyOffset = document.getElementById('applyPoleOffset').checked;
            document.getElementById('offsetDetails').style.display = applyOffset ? 'block' : 'none';
            document.getElementById('noOffsetDetails').style.display = applyOffset ? 'none' : 'block';
            
            // If currently collecting or have results, warn user
            if (isCollecting) {
                alert('Warning: Offset setting changed during collection. Please stop and restart collection for consistent results.');
            } else if (averagedPoint) {
                alert('Offset setting changed. Previous results used ' + (averagedPoint.offsetApplied ? 'with' : 'without') + ' offset.');
            }
        }

        // Initialize map
        function initMap() {
            map = L.map('map').setView([37.7749, -122.4194], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Try to get user's location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        map.setView([lat, lon], 16);
                        
                        if (currentMarker) {
                            map.removeLayer(currentMarker);
                        }
                        currentMarker = L.marker([lat, lon]).addTo(map);
                        currentMarker.bindPopup('Your Location').openPopup();
                    },
                    (error) => {
                        console.log('Geolocation error:', error);
                    }
                );
            }
        }

        // Bluetooth connection for Arrow device
        async function requestBluetoothDevice() {
            try {
                // Request Bluetooth device with GPS service
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['location_and_navigation'] }
                    ],
                    optionalServices: ['battery_service', 'device_information']
                });

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService('location_and_navigation');
                gpsCharacteristic = await service.getCharacteristic('location_and_speed');

                document.getElementById('deviceStatus').innerHTML = 
                    '<span class="status-badge status-connected">‚úÖ Arrow Device Connected</span>';
                
                alert('Arrow device connected successfully!');

            } catch (error) {
                console.error('Bluetooth connection error:', error);
                alert('Could not connect to Arrow device. Using browser GPS instead.\n\nError: ' + error.message);
            }
        }

        // Start point collection
        function startCollection() {
            const pointName = document.getElementById('pointName').value.trim();
            if (!pointName) {
                alert('Please enter a point name');
                return;
            }

            targetPoints = parseInt(document.getElementById('numPoints').value) || 50;
            if (targetPoints < 10 || targetPoints > 200) {
                alert('Please enter a number between 10 and 200');
                return;
            }

            readings = [];
            isCollecting = true;
            
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            document.getElementById('deviceStatus').innerHTML += 
                '<span class="status-badge status-collecting">üîÑ Collecting...</span>';

            // Start watching position
            const options = {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 5000
            };

            watchId = navigator.geolocation.watchPosition(
                handlePosition,
                handleError,
                options
            );
        }

        // Stop point collection
        function stopCollection() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            isCollecting = false;
            
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
            
            // Remove collecting badge
            const badges = document.querySelectorAll('.status-collecting');
            badges.forEach(badge => badge.remove());

            if (readings.length > 0) {
                calculateAverage();
            } else {
                alert('No readings collected');
            }
        }

        // Handle position update
        function handlePosition(position) {
            if (!isCollecting) return;

            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const alt = position.coords.altitude || 0;
            const elevFeet = convertElevationToFeet(alt);
            const accuracy = position.coords.accuracy;

            readings.push({
                lat: lat,
                lon: lon,
                alt: alt,
                altFeet: elevFeet,
                accuracy: accuracy,
                timestamp: new Date()
            });

            // Update UI
            const progress = (readings.length / targetPoints) * 100;
            document.getElementById('pointCount').textContent = `${readings.length} / ${targetPoints}`;
            document.getElementById('progressBar').style.width = `${progress}%`;
            document.getElementById('progressBar').textContent = `${Math.round(progress)}%`;
            document.getElementById('currentAccuracy').textContent = `¬±${metersToFeet(accuracy).toFixed(2)} ft`;

            // Update map
            showCurrentPoint(lat, lon);

            // Auto-stop when target reached
            if (readings.length >= targetPoints) {
                stopCollection();
            }
        }

        // Handle geolocation errors
        function handleError(error) {
            console.error('Geolocation error:', error);
            let message = 'Error getting location: ';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message += 'Permission denied. Please enable location access.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += 'Position unavailable.';
                    break;
                case error.TIMEOUT:
                    message += 'Request timed out.';
                    break;
                default:
                    message += 'Unknown error.';
            }
            
            alert(message);
        }

        // Show current point on map
        function showCurrentPoint(lat, lon) {
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            currentMarker = L.circleMarker([lat, lon], {
                radius: 8,
                fillColor: '#667eea',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);

            currentMarker.bindPopup(`
                <strong>Current Reading</strong><br>
                Lat: ${lat.toFixed(8)}¬∞<br>
                Lon: ${lon.toFixed(8)}¬∞<br>
                Readings: ${readings.length}/${targetPoints}
            `);

            map.setView([lat, lon], map.getZoom() || 18);
        }

        // Calculate average position
        function calculateAverage() {
            if (readings.length === 0) return;

            const pointName = document.getElementById('pointName').value.trim();

            // Calculate averages
            const sumLat = readings.reduce((sum, r) => sum + r.lat, 0);
            const sumLon = readings.reduce((sum, r) => sum + r.lon, 0);
            const sumAltFeet = readings.reduce((sum, r) => sum + r.altFeet, 0);

            const avgLat = sumLat / readings.length;
            const avgLon = sumLon / readings.length;
            const avgElevFeet = sumAltFeet / readings.length;

            // Calculate standard deviation (in feet)
            const variance = readings.reduce((sum, r) => {
                const dLat = (r.lat - avgLat) * 111320 * 3.28084; // degrees to feet
                const dLon = (r.lon - avgLon) * 111320 * 3.28084 * Math.cos(avgLat * Math.PI / 180); // degrees to feet
                const dAlt = r.altFeet - avgElevFeet; // already in feet
                return sum + (dLat * dLat + dLon * dLon + dAlt * dAlt);
            }, 0) / readings.length;

            const stdDev = Math.sqrt(variance); // result in feet

            // Store averaged point
            averagedPoint = {
                name: pointName,
                lat: avgLat,
                lon: avgLon,
                altFeet: avgElevFeet,
                stdDev: stdDev,
                numReadings: readings.length,
                readings: [...readings],
                timestamp: new Date(),
                offsetApplied: document.getElementById('applyPoleOffset').checked
            };

            // Add to collection history
            allCollectedPoints.push(averagedPoint);

            // Update UI
            const offsetLabel = averagedPoint.offsetApplied ? ' (NAVD88)' : ' (Ellipsoidal)';
            document.getElementById('avgLat').textContent = avgLat.toFixed(8) + '¬∞';
            document.getElementById('avgLon').textContent = avgLon.toFixed(8) + '¬∞';
            document.getElementById('avgElev').textContent = avgElevFeet.toFixed(3) + ' ft' + offsetLabel;
            document.getElementById('stdDev').textContent = stdDev.toFixed(4) + ' ft';
            document.getElementById('numSamples').textContent = readings.length;
            
            document.getElementById('resultsContainer').classList.remove('hidden');
            
            // Update history
            updateHistoryDisplay();

            // Display on map
            displayAveragedPoint(avgLat, avgLon);
        }

        // Display averaged point on map
        function displayAveragedPoint(lat, lon) {
            if (averagedMarker) {
                map.removeLayer(averagedMarker);
            }

            averagedMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'custom-marker',
                    html: '<div style="background: #28a745; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">‚úì</div>',
                    iconSize: [30, 30]
                })
            }).addTo(map);

            const offsetLabel = averagedPoint.offsetApplied ? ' (NAVD88)' : ' (Ellipsoidal)';
            averagedMarker.bindPopup(`
                <strong>${averagedPoint.name}</strong><br>
                Lat: ${lat.toFixed(8)}¬∞<br>
                Lon: ${lon.toFixed(8)}¬∞<br>
                Elev: ${averagedPoint.altFeet.toFixed(3)} ft${offsetLabel}<br>
                Samples: ${averagedPoint.numReadings}<br>
                Std Dev: ${averagedPoint.stdDev.toFixed(4)} ft
            `).openPopup();

            map.setView([lat, lon], 20);
        }

        // Update history display
        function updateHistoryDisplay() {
            if (allCollectedPoints.length === 0) return;

            document.getElementById('historyContainer').classList.remove('hidden');
            
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = allCollectedPoints.map((point, index) => `
                <div class="coordinate-display" style="cursor: pointer;" onclick="viewPoint(${index})">
                    <div>
                        <strong>${point.name}</strong><br>
                        <small>${point.timestamp.toLocaleString()}</small>
                    </div>
                    <div style="text-align: right;">
                        <span style="font-size: 0.9rem;">${point.numReadings} readings</span>
                    </div>
                </div>
            `).join('');
        }

        // View a specific point from history
        function viewPoint(index) {
            const point = allCollectedPoints[index];
            map.setView([point.lat, point.lon], 20);
            
            const offsetLabel = point.offsetApplied ? ' (NAVD88)' : ' (Ellipsoidal)';
            // Show point details
            L.popup()
                .setLatLng([point.lat, point.lon])
                .setContent(`
                    <strong>${point.name}</strong><br>
                    Lat: ${point.lat.toFixed(8)}¬∞<br>
                    Lon: ${point.lon.toFixed(8)}¬∞<br>
                    Elev: ${point.altFeet.toFixed(3)} ft${offsetLabel}<br>
                    Samples: ${point.numReadings}<br>
                    Std Dev: ${point.stdDev.toFixed(4)} ft
                `)
                .openOn(map);
        }

        // Export functions
        function exportCSV() {
            if (!averagedPoint) return;

            const pointName = averagedPoint.name;
            const offsetLabel = averagedPoint.offsetApplied ? 'NAVD88' : 'Ellipsoidal';
            let csv = `Point Name,Latitude,Longitude,Elevation (ft ${offsetLabel}),Accuracy (ft),Timestamp\n`;
            
            // Add summary row
            csv += `${pointName} (Average),${averagedPoint.lat.toFixed(8)},${averagedPoint.lon.toFixed(8)},${averagedPoint.altFeet.toFixed(3)},${averagedPoint.stdDev.toFixed(4)},${averagedPoint.timestamp.toISOString()}\n`;
            csv += `Offset Applied: ${averagedPoint.offsetApplied ? 'Yes (2.035m)' : 'No'}\n\n`;
            
            // Add all readings
            csv += 'Individual Readings:\n';
            csv += `Reading #,Latitude,Longitude,Elevation (ft),Accuracy (ft),Timestamp\n`;
            readings.forEach((r, i) => {
                csv += `${i+1},${r.lat.toFixed(8)},${r.lon.toFixed(8)},${r.altFeet.toFixed(3)},${metersToFeet(r.accuracy).toFixed(2)},${r.timestamp.toISOString()}\n`;
            });

            downloadFile(csv, `${pointName}_RTK_Data.csv`, 'text/csv');
        }

        function exportGeoJSON() {
            if (!averagedPoint) return;

            const offsetLabel = averagedPoint.offsetApplied ? 'NAVD88' : 'Ellipsoidal';
            const geojson = {
                type: 'FeatureCollection',
                features: [
                    {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [averagedPoint.lon, averagedPoint.lat, averagedPoint.altFeet * 0.3048]
                        },
                        properties: {
                            name: averagedPoint.name,
                            elevation_ft: averagedPoint.altFeet.toFixed(3),
                            elevation_datum: offsetLabel,
                            elevation_m: (averagedPoint.altFeet * 0.3048).toFixed(3),
                            std_deviation_ft: averagedPoint.stdDev.toFixed(4),
                            std_deviation_m: (averagedPoint.stdDev * 0.3048).toFixed(4),
                            offset_applied: averagedPoint.offsetApplied,
                            offset_value_m: averagedPoint.offsetApplied ? '2.035' : '0',
                            num_readings: averagedPoint.numReadings,
                            timestamp: averagedPoint.timestamp.toISOString()
                        }
                    }
                ]
            };

            downloadFile(JSON.stringify(geojson, null, 2), `${averagedPoint.name}_RTK_Data.geojson`, 'application/geo+json');
        }

        function exportKML() {
            if (!averagedPoint) return;

            const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${averagedPoint.name}</name>
    <description>RTK averaged point with ${averagedPoint.numReadings} readings</description>
    <Placemark>
      <name>${averagedPoint.name}</name>
      <description>
        Elevation: ${averagedPoint.altFeet.toFixed(3)} ft (${averagedPoint.offsetApplied ? 'NAVD88' : 'Ellipsoidal'})
        ${averagedPoint.offsetApplied ? 'Offset Applied: 2.035m' : 'No Offset Applied'}
        Std Dev: ${averagedPoint.stdDev.toFixed(4)} ft
        Readings: ${averagedPoint.numReadings}
        Collected: ${averagedPoint.timestamp.toLocaleString()}
      </description>
      <Point>
        <coordinates>${averagedPoint.lon.toFixed(8)},${averagedPoint.lat.toFixed(8)},${(averagedPoint.altFeet * 0.3048).toFixed(3)}</coordinates>
      </Point>
    </Placemark>
  </Document>
</kml>`;

            downloadFile(kml, `${averagedPoint.name}_RTK_Data.kml`, 'application/vnd.google-earth.kml+xml');
        }

        function exportGPX() {
            if (!averagedPoint) return;

            const gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Arrow EOS RTK Tool" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${averagedPoint.name}</name>
    <desc>RTK averaged point with ${averagedPoint.numReadings} readings</desc>
    <time>${averagedPoint.timestamp.toISOString()}</time>
  </metadata>
  <wpt lat="${averagedPoint.lat.toFixed(8)}" lon="${averagedPoint.lon.toFixed(8)}">
    <ele>${(averagedPoint.altFeet * 0.3048).toFixed(3)}</ele>
    <time>${averagedPoint.timestamp.toISOString()}</time>
    <name>${averagedPoint.name}</name>
    <desc>Elev: ${averagedPoint.altFeet.toFixed(3)} ft (${averagedPoint.offsetApplied ? 'NAVD88' : 'Ellipsoidal'}), ${averagedPoint.offsetApplied ? 'Offset: 2.035m' : 'No Offset'}, Std Dev: ${averagedPoint.stdDev.toFixed(4)} ft, Readings: ${averagedPoint.numReadings}</desc>
  </wpt>
</gpx>`;

            downloadFile(gpx, `${averagedPoint.name}_RTK_Data.gpx`, 'application/gpx+xml');
        }

        function copyCoordinates() {
            if (!averagedPoint) return;

            const offsetLabel = averagedPoint.offsetApplied ? 'NAVD88' : 'Ellipsoidal';
            const offsetNote = averagedPoint.offsetApplied ? '\nOffset Applied: 2.035m (pole + plate + phase center)' : '\nNo Offset Applied';
            const text = `${averagedPoint.name}
Latitude: ${averagedPoint.lat.toFixed(8)}¬∞
Longitude: ${averagedPoint.lon.toFixed(8)}¬∞
Elevation: ${averagedPoint.altFeet.toFixed(3)} ft (${offsetLabel})${offsetNote}
Standard Deviation: ${averagedPoint.stdDev.toFixed(4)} ft
Readings: ${averagedPoint.numReadings}
Collected: ${averagedPoint.timestamp.toLocaleString()}`;

            navigator.clipboard.writeText(text).then(() => {
                alert('Coordinates copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard. Please copy manually.');
            });
        }

        function exportAllPoints() {
            if (allCollectedPoints.length === 0) return;

            let csv = 'Point Name,Latitude,Longitude,Elevation (ft),Datum,Offset Applied,Std Deviation (ft),Num Readings,Timestamp\n';
            
            allCollectedPoints.forEach(point => {
                const datum = point.offsetApplied ? 'NAVD88' : 'Ellipsoidal';
                const offset = point.offsetApplied ? 'Yes (2.035m)' : 'No';
                csv += `${point.name},${point.lat.toFixed(8)},${point.lon.toFixed(8)},${point.altFeet.toFixed(3)},${datum},${offset},${point.stdDev.toFixed(4)},${point.numReadings},${point.timestamp.toISOString()}\n`;
            });

            downloadFile(csv, 'All_RTK_Points.csv', 'text/csv');
        }

        // Utility function to download files
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // Initialize on page load
        window.onload = function() {
            initMap();
            
            // Set default point name with timestamp
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
            document.getElementById('pointName').value = `PT-${timestamp}`;

            // Check for geolocation support
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser. Please use a modern browser.');
            }

            // Check for Bluetooth support
            if (!navigator.bluetooth) {
                console.log('Web Bluetooth API is not available. Arrow device connection will not work.');
            }
        };
    </script>
</body>
</html>
